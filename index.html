<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>陈金星写字的地方</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="less is more">
<meta property="og:type" content="website">
<meta property="og:title" content="陈金星写字的地方">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="陈金星写字的地方">
<meta property="og:description" content="less is more">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="陈金星写字的地方">
<meta name="twitter:description" content="less is more">
  
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">陈金星写字的地方</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">less is more</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-redis入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/10/redis入门/" class="article-date">
  <time datetime="2017-05-10T11:06:07.000Z" itemprop="datePublished">2017-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/10/redis入门/">redis入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="安装gcc"><a href="#安装gcc" class="headerlink" title="安装gcc"></a>安装gcc</h2><ul>
<li><p>Redis在linux上的安装首先必须先安装gcc，这个是用来编译redis的源文件的。首先需要先切换的到root用户：</p>
<pre><code>[chenjx@localhost ~]$ su
Password: 
[root@localhost chenjx]#
</code></pre></li>
<li><p>然后开始安装gcc:</p>
<pre><code>//这个命令是在线安装的，所以在这之前你的PC必须能够上网
[root@localhost /]# yum install gcc-c++
</code></pre></li>
</ul>
<h2 id="解压redis的源文件"><a href="#解压redis的源文件" class="headerlink" title="解压redis的源文件"></a>解压redis的源文件</h2><pre><code>[root@localhost chenjx]# cd Desktop/
[root@localhost Desktop]# ls
redis-4.0.1.tar.gz
[root@localhost Desktop]# tar zxvf redis-4.0.1.tar.gz 
redis-4.0.1/
redis-4.0.1/.gitignore
redis-4.0.1/00-RELEASENOTES
redis-4.0.1/BUGS
redis-4.0.1/CONTRIBUTING
</code></pre><h2 id="进入redis的解压目录"><a href="#进入redis的解压目录" class="headerlink" title="进入redis的解压目录"></a>进入redis的解压目录</h2><pre><code>[root@localhost Desktop]# ls
redis-4.0.1  redis-4.0.1.tar.gz
[root@localhost Desktop]# cd redis-4.0.1/
</code></pre><h2 id="使用make命令编译"><a href="#使用make命令编译" class="headerlink" title="使用make命令编译"></a>使用make命令编译</h2><pre><code>[root@localhost redis-4.0.1]# make

//出现以下信息即是编译成功
CC notify.o
CC setproctitle.o
CC blocked.o
CC hyperloglog.o
CC latency.o
CC sparkline.o
CC redis-check-rdb.o
CC redis-check-aof.o
CC geo.o
CC lazyfree.o
CC module.o
CC evict.o
CC expire.o
CC geohash.o
CC geohash_helper.o
CC childinfo.o
CC defrag.o
CC siphash.o
CC rax.o
LINK redis-server
INSTALL redis-sentinel
CC redis-cli.o
LINK redis-cli
CC redis-benchmark.o
LINK redis-benchmark
INSTALL redis-check-rdb
INSTALL redis-check-aof
</code></pre><p>进入解压的src目录下</p>
<pre><code>[root@localhost redis-4.0.1]# cd src
</code></pre><p>运行make test测试是否可以安装,检查的一大堆，都是绿色的ok。这就可以了</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>[root@localhost src]# make PREFIX=/usr/local/redis install 
</code></pre><p>安装成功后，去/usr/local/redis/bin目录看，会发现如下文件：</p>
<p><img src="https://i.imgur.com/esFeEOX.png" alt=""></p>
<p>都是一个个工具命令</p>
<p>然后把解压的redis路径下的redis.conf文件拷贝到安装路径/usr/local/redis下面</p>
<pre><code>[root@localhost redis-4.0.1]# cp redis.conf /usr/local/redis
[root@localhost redis-4.0.1]# cd /usr/local/redis
[root@localhost redis]# ls
bin  redis.conf
</code></pre><p>到这里redis已经安装成功了。</p>
<h2 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h2><h4 id="第一种方法：进入安装路径下的bin"><a href="#第一种方法：进入安装路径下的bin" class="headerlink" title="第一种方法：进入安装路径下的bin"></a>第一种方法：进入安装路径下的bin</h4><pre><code>[root@localhost redis]# cd bin
[root@localhost bin]# ./redis-server
</code></pre><p>但是这属于前端启动，启动redis之后，我们的控制台就不能进行任何操作了。只能ctrl+c停止启动。</p>
<h4 id="第二种方法：后端启动"><a href="#第二种方法：后端启动" class="headerlink" title="第二种方法：后端启动"></a>第二种方法：后端启动</h4><ul>
<li><p>首先编辑redis.conf</p>
<p>  [root@localhost redis]# vim redis.conf</p>
</li>
<li><p>找到daemonize no将其改为yes</p>
</li>
<li><p>再次启动 </p>
<pre><code>[root@localhost redis]# ls
bin  redis.conf
[root@localhost redis]# ./bin/redis-server ./redis.conf
//这里加载配置文件

80167:C 30 Jul 16:01:58.145 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo
80167:C 30 Jul 16:01:58.145 # Redis version=4.0.1, bits=64, commit=00000000, modified=0, pid=80167, just started
80167:C 30 Jul 16:01:58.145 # Configuration loaded
</code></pre></li>
</ul>
<p>这样redis就启动了</p>
<pre><code>可以通过
ps -ef|grep redis
来查看是否启动
</code></pre><p>关闭redis</p>
<pre><code>[root@localhost redis]# ./bin/redis-cli shutdown
</code></pre><h2 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h2><pre><code>//首先链接客户端
[root@localhost redis]# ./bin/redis-cli
//检查网络是否可以
127.0.0.1:6379&gt; ping
PONG
//设置一个键值对
127.0.0.1:6379&gt; set name chenjx
OK
//获取刚刚设置的键值对
127.0.0.1:6379&gt; get name
&quot;chenjx&quot;
//查看所有的键
127.0.0.1:6379&gt; keys *
1) &quot;name&quot;
//删除name这个键
127.0.0.1:6379&gt; del name
(integer) 1
127.0.0.1:6379&gt; keys *
(empty list or set)
127.0.0.1:6379&gt;
</code></pre><h2 id="设置登录密码"><a href="#设置登录密码" class="headerlink" title="设置登录密码"></a>设置登录密码</h2><p>redis在生产环境中通常都会设置密码以保证一定的安全性</p>
<h4 id="首先修改redis-conf"><a href="#首先修改redis-conf" class="headerlink" title="首先修改redis.conf"></a>首先修改redis.conf</h4><p>打开redis.conf文件，搜索requirepass关键字</p>
<pre><code>################################## SECURITY ###################################

# Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other
# commands.  This might be useful in environments in which you do not trust
# others with access to the host running redis-server.
#
# This should stay commented out for backward compatibility and because most
# people do not need auth (e.g. they run their own servers).
#
# Warning: since Redis is pretty fast an outside user can try up to
# 150k passwords per second against a good box. This means that you should
# use a very strong password otherwise it will be very easy to break.
#
# requirepass foobared
</code></pre><p>关注标记的那一行，#requirepass foobared。设置密码的方法就是去掉注释的#，把foobared替换成自己的密码即可，例如将密码设置为123456： </p>
<pre><code>################################## SECURITY ###################################

# Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other
# commands.  This might be useful in environments in which you do not trust
# others with access to the host running redis-server.
#
# This should stay commented out for backward compatibility and because most
# people do not need auth (e.g. they run their own servers).
#
# Warning: since Redis is pretty fast an outside user can try up to
# 150k passwords per second against a good box. This means that you should
# use a very strong password otherwise it will be very easy to break.
#
requirepass 123456
</code></pre><p>修改完成后重启redis，再次通过redis客户端redis-cli登录并操作可以发现会报一个身份认证错误：</p>
<p><img src="https://i.imgur.com/sR9PtPZ.png" alt=""></p>
<p>这就说明我们已经成功的设置了密码，所以通过客户端连接的话必须加上密码参数才能正常连接： </p>
<p><img src="https://i.imgur.com/EpEgFQr.png" alt=""></p>
<p>如上图所示，加了-a参数之后即可正常连接并操作redis。</p>
<h2 id="jedis连接设置密码"><a href="#jedis连接设置密码" class="headerlink" title="jedis连接设置密码"></a>jedis连接设置密码</h2><p>当我们用Java客户端连接redis时会遇到同样的问题，下面看一段简单的jedis连接redis的测试代码：</p>
<pre><code>@Test
public void testTwo() {
    Jedis jedis = new Jedis(&quot;192.168.145.10&quot;);
    System.out.println(&quot;Connection to server sucessfully&quot;);
    // 查看服务是否运行
    System.out.println(&quot;Server is running: &quot; + jedis.ping());
}
</code></pre><p>运行junit后我们发现报异常了：</p>
<pre><code>redis.clients.jedis.exceptions.JedisDataException: NOAUTH Authentication required.
at redis.clients.jedis.Protocol.processError(Protocol.java:117)
at redis.clients.jedis.Protocol.process(Protocol.java:142)
at redis.clients.jedis.Protocol.read(Protocol.java:196)
</code></pre><p>由于我们设置了密码但在这里又没有指定密码，所以报了和刚才相同的错误,Jedis的父类BinaryJedis提供了这样一样方法：</p>
<pre><code>public String auth(final String password) {
    checkIsInMulti();
    client.auth(password);
    return client.getStatusCodeReply();
}
</code></pre><p>所以在创建了Jedis的实例后再加上一行jedis.auth(“123456”); 即可</p>
<pre><code>@Test
public void testTwo() {
    Jedis jedis = new Jedis(&quot;192.168.145.10&quot;);
    jedis.auth(&quot;123456&quot;);
    System.out.println(&quot;Connection to server sucessfully&quot;);
    // 查看服务是否运行
    System.out.println(&quot;Server is running: &quot; + jedis.ping());
}
</code></pre><p><img src="https://i.imgur.com/MpHJLvu.png" alt=""></p>
<h2 id="spring-data-redis设置密码"><a href="#spring-data-redis设置密码" class="headerlink" title="spring-data-redis设置密码"></a>spring-data-redis设置密码</h2><p>通常情况下在实际的java项目中我们会选择Spring提供的spring-data-redis来操作redis，spring的封装可以给我们提供很多便捷之处。那么spring-data-redis又是如何设置密码的呢？首先定义一个redis.properties配置文件，定义一组redis属性供spring加载使用，其中就包含密码（redis.password）：</p>
<pre><code># Redis settings  
redis.host=192.168.145.10 
redis.port=6379  
redis.password=123456
redis.database=2
redis.timeout=100000  
redis.maxTotal=300  
redis.maxIdle=100
redis.minIdle=10
redis.maxWaitMillis=1000  
redis.testOnBorrow=true  
</code></pre><p>然后在由Spring封装的JedisConnectionFactory中来设置密码属性即可，下面是完整redis配置：</p>
<pre><code>&lt;!-- redis配置 --&gt;
&lt;bean id=&quot;poolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;
    &lt;property name=&quot;maxIdle&quot; value=&quot;${redis.maxIdle}&quot; /&gt;
    &lt;property name=&quot;maxWaitMillis&quot; value=&quot;${redis.maxWaitMillis}&quot; /&gt;
    &lt;property name=&quot;testOnBorrow&quot; value=&quot;${redis.testOnBorrow}&quot; /&gt;
&lt;/bean&gt;

&lt;bean id=&quot;connectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;
    p:host-name=&quot;${redis.host}&quot; p:port=&quot;${redis.port}&quot; 
    p:password=&quot;${redis.password}&quot; p:pool-config-ref=&quot;poolConfig&quot; /&gt;

&lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.StringRedisTemplate&quot;&gt;
    &lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot; /&gt;
&lt;/bean&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/10/redis入门/" data-id="cjkqla1tl000o2kpxoai4c1wm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-kafka集群" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/01/07/kafka集群/" class="article-date">
  <time datetime="2017-01-07T04:16:17.000Z" itemprop="datePublished">2017-01-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/07/kafka集群/">kafka集群</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Kafka初识"><a href="#Kafka初识" class="headerlink" title="Kafka初识"></a>Kafka初识</h2><ul>
<li><p>Kafka使用背景</p>
<p>  在我们大量使用分布式数据库、分布式计算集群的时候，是否会遇到这样的一些问题：</p>
<ul>
<li>我们想分析下用户行为（pageviews），以便我们设计出更好的广告位</li>
<li>我想对用户的搜索关键词进行统计，分析出当前的流行趋势</li>
<li>有些数据，存储数据库浪费，直接存储硬盘效率又低</li>
</ul>
</li>
<li><p>Kafka的定义</p>
<p>  它是一个分布式消息系统,具有高水平扩展和高吞吐量的特点。</p>
</li>
</ul>
<h2 id="Kafka相关概念"><a href="#Kafka相关概念" class="headerlink" title="Kafka相关概念"></a>Kafka相关概念</h2><ul>
<li><p>AMQP协议：是一个标准开放的应用层的消息中间件（Message Oriented Middleware）协议。AMQP定义了通过网络发送的字节流的数据格式。因此兼容性非常好，任何实现AMQP协议的程序都可以和与AMQP协议兼容的其他程序交互，可以很容易做到跨语言，跨平台。</p>
</li>
<li><p>一些基本的概念</p>
<ul>
<li>消费者：（Consumer）：从消息队列中请求消息的客户端应用程序</li>
<li>生产者：（Producer）：向broker发布消息的应用程序</li>
<li>AMQP服务端（broker）：用来接收生产者发送的消息并将这些消息路由给服务器中的队列，便于fafka将生产者发送的消息，动态的添加到磁盘并给每一条消息一个偏移量，所以对于kafka一个broker就是一个应用程序的实例</li>
</ul>
</li>
</ul>
<p>kafka支持的客户端语言：Kafka客户端支持当前大部分主流语言，包括：C、C++、Erlang、Java、.net、perl、PHP、Python、Ruby、Go、Javascript<br>可以使用以上任何一种语言和kafka服务器进行通信（即辨析自己的consumer从kafka集群订阅消息也可以自己写producer程序）</p>
<ul>
<li><p>Kafka架构</p>
<p>  生产者生产消息、kafka集群、消费者获取消息这样一种架构，如下图：</p>
<p>  <img src="https://i.imgur.com/fFh8aZr.png" alt=""></p>
<p>  kafka集群中的消息，是通过Topic（主题）来进行组织的，如下图：</p>
<p>  <img src="https://i.imgur.com/yMOoyNJ.png" alt=""></p>
<p>  一些基本的概念：</p>
<ul>
<li>主题（Topic）：一个主题类似新闻中的体育、娱乐、教育等分类概念，在实际工程中通常一个业务一个主题。</li>
<li><p>分区（Partition）：一个Topic中的消息数据按照多个分区组织，分区是kafka消息队列组织的最小单位，一个分区可以看作是一个FIFO（ First Input First Output的缩写，先入先出队列）的队列。</p>
<p>kafka分区是提高kafka性能的关键所在，当你发现你的集群性能不高时，常用手段就是增加Topic的分区，分区里面的消息是按照从新到老的顺序进行组织，消费者从队列头订阅消息，生产者从队列尾添加消息。</p>
<p>工作图：<br><img src="https://i.imgur.com/4eSzo4r.png" alt=""></p>
<p>备份（Replication）：为了保证分布式可靠性，kafka0.8开始对每个分区的数据进行备份（不同的Broker上），防止其中一个Broker宕机造成分区上的数据不可用。</p>
</li>
</ul>
</li>
</ul>
<h2 id="Kafka集群搭建"><a href="#Kafka集群搭建" class="headerlink" title="Kafka集群搭建"></a>Kafka集群搭建</h2><ul>
<li><p>软件环境</p>
<ul>
<li>已经搭建好的zookeeper集群(文章最后另写)</li>
<li>软件版本kafka_2.11-0.9.0.1.tgz</li>
<li>软件版本kafka_2.11-0.9.0.1.tgz</li>
</ul>
</li>
<li><p>创建目录并下载安装软件</p>
<pre><code>#下载软件
wget https://archive.apache.org/dist/kafka/0.9.0.1/kafka_2.11-0.9.0.1.tgz
#解压软件
tar -xvf kafka_2.11-0.9.0.1.tgz
</code></pre></li>
<li><p>修改配置文件</p>
<p>  主要关注config/server.properties     </p>
<pre><code>broker.id=0  #当前机器在集群中的唯一标识，和zookeeper的myid性质一样
port=9092 #当前kafka对外提供服务的端口默认是9092
host.name = 120.76.230.134 #这个参数默认是关闭的，在0.8.1有个bug，DNS解析问题，失败率的问题
#申明此kafka服务器需要监听的端口号，如果是在本机上跑虚拟机运行可以不用配置本项，默认会使用localhost的地址，如果是在远程服务器上运行则必须配置
listeners = PLAINTEXT://120.76.230.134:9092 
advertised.host.name = 120.76.230.134
advertised.listeners=PLAINTEXT://120.76.230.134:9092
log.dirs=/data/kafka/kafkalogs  #消息存放的目录
#在log.retention.hours=168 下面新增下面三项
message.max.byte=5242880
default.replication.factor=2
replica.fetch.max.bytes=5242880
zookeeper.connect=120.76.230.134:5181,120.76.193.192:5181,120.25.239.155:5181 #zookeeper配置地址
</code></pre></li>
</ul>
<pre><code>每个机子的broker.id、host.name都是不一样的，主要是关注以上几项参数配置。
</code></pre><ul>
<li><p>启动Kafka集群并测试</p>
<p>  启动服务</p>
<pre><code>#从后台启动Kafka集群（3台都需要启动）
cd /data/kafka/kafka_2.11-0.11.0.1/bin #进入到kafka的bin目录 
./kafka-server-start.sh -daemon ../config/server.properties
</code></pre><p>  检查服务是否启动</p>
<pre><code>#执行命令jps
22246 Bootstrap
26393 Kafka
</code></pre><p>  创建Topic来验证是否创建成功</p>
<pre><code>#创建Topic
./kafka-topics.sh --create --zookeeper 120.76.230.134:5181,120.76.193.192:5181,120.25.239.155:5181 --replication-factor 2 --partitions 1 --topic test

#解释
--replication-factor 2   #复制两份
--partitions 1 #创建1个分区
--topic #主题为test

#在一台服务器上创建一个发布者
#创建一个broker，发布者
./kafka-console-producer.sh --broker-list 120.76.230.134:9092 --topic test

#在一台服务器上创建一个订阅者
./kafka-console-consumer.sh --bootstrap-server 120.76.230.134:9092 --topic test --from-beginning
</code></pre><p>  测试（在发布者那里发布消息看看订阅者那里是否能正常收到~）：</p>
</li>
<li><p>其他命令    </p>
<p>  大部分命令可以去官方文档查看</p>
<ul>
<li><p>查看topic</p>
<pre><code>./kafka-topics.sh --list --zookeeper 120.76.230.134:5181,120.76.193.192:5181,120.25.239.155:5181
#就会显示我们创建的所有topic
</code></pre><p>kafka集群搭建完毕</p>
</li>
</ul>
</li>
</ul>
<h2 id="zookeeper集群部署"><a href="#zookeeper集群部署" class="headerlink" title="zookeeper集群部署"></a>zookeeper集群部署</h2><ul>
<li><p>为什么是基数</p>
<ul>
<li>集群必须有一半以上的机器统一才能成为leader</li>
<li>一半的机器挂掉 整个集群挂掉</li>
</ul>
</li>
<li><p>去官网下载好zookeeper包，解压</p>
</li>
<li><p>修改配置/conf/zoo.cfg文件</p>
<pre><code># 基本事件单元，以毫秒为单位，用来控制心跳和超时
tickTime=2000
# 参数设定了允许所有跟随者与领导者进行连接并同步的时间，如果在设定的时间段内，半数以上的跟随者未能完成同步，领导者便会宣布放弃领导地位，进行另一次的领导选举
# 如果zk集群环境数量确实很大，同步数据的时间会变长，因此这种情况下可以适当调大该参数
#集群中的follower服务器(F)与leader服务器(L)之间 初始连接 时能容忍的最多心跳数（tickTime的数量）
initLimit=10
# 参数设定了允许一个跟随者与一个领导者进行同步的时间，如果在设定的时间段内，跟随者未完成同步，它将会被集群丢弃
# 所有关联到这个跟随者的客户端将连接到另外一个跟随着
syncLimit=5
# 存储持久数据的本地文件系统位置
dataDir=/data/zookeeper-3.4.9/data
dataLogDir=/data/zookeeper-3.4.9/logs
# 监听客户端连接的端口
clientPort=5181

server.1=120.76.230.134:2888:3888
server.2=120.76.193.192:2888:3888
server.3=120.25.239.155:2888:3888

#server.1 这个1是服务器的标识也可以是其他的数字， 表示这个是第几号服务器，用来标识服务器，这个标识要写到快照目录下面myid文件里
#120.76.230.134为集群里的IP地址，第一个端口是master和slave之间的通信端口，默认是2888，第二个端口是leader选举的端口，集群刚启动的时候选举或者leader挂掉之后进行新的选举的端口默认是3888
</code></pre><p>  zoo_sample.cfg  这个文件是官方给我们的zookeeper的样板文件，给他复制一份命名为zoo.cfg，zoo.cfg是官方指定的文件命名规则。</p>
</li>
<li><p>创建myid文件</p>
<p>  /data/zookeeper-3.4.9/data目录下要配置myid文件，内容跟server.id相对应，比如:1</p>
<p>  ./zkServer.sh star启动zookeeper，每台都要启动一遍</p>
</li>
<li><p>重要配置说明</p>
<ul>
<li><p>myid文件和server.myid  在快照目录下存放的标识本台服务器的文件，他是整个zk集群用来发现彼此的一个重要标识。</p>
</li>
<li><p>zoo.cfg 文件是zookeeper配置文件 在conf目录里。</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/01/07/kafka集群/" data-id="cjkqla1se000f2kpxi0wsobqv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分布式/">分布式</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-快速排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/04/快速排序/" class="article-date">
  <time datetime="2016-06-04T12:21:10.000Z" itemprop="datePublished">2016-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/04/快速排序/">快速排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>在数组中找一个支点(任意),经过一趟排序后，支点左边的数都要比支点小，支点右边的数都要比支点大！</p>
<p>现在我们有一个数组：int arr[]={1,4,5,67,2,7,8,6,9,44};</p>
<p>经过一趟排序之后，如果我选择数组中间的数作为支点：7(任意的)，那么第一趟排序后的结果是这样的：{1,4,5,6,2,7,8,67,9,44}</p>
<p>那么就实现了支点左边的数比支点小，支点右边的数比支点大</p>
<h4 id="递归分析与代码实现"><a href="#递归分析与代码实现" class="headerlink" title="递归分析与代码实现"></a>递归分析与代码实现</h4><p>现在我们的数组是这样的：{1,4,5,6,2,7,8,67,9,44}，既然我们比7小的在左边，比7大的在右边，那么我们只要将”左边“的排好顺序，又将”右边“的排好序，那整个数组是不是就有序了？</p>
<p>回顾一下递归：”左边“的排好顺序，”右边“的排好序，跟我们第一趟排序的做法是一样的。</p>
<p>只不过是参数不一样：第一趟排序是任选了一个支点，比支点小的在左边，比支点大的在右边。那么，我们想要”左边“的排好顺序，只要在”左边“部分找一个支点，比支点小的在左边，比支点大的在右边。</p>
<p>递归出口也很容易找到：如果数组只有一个元素时，那么就不用排序了</p>
<p>代码如下：</p>
<pre><code>public static void main(String[] args) {
    int[] arr = {1, 4, 5, 67, 2, 7, 8, 6, 9, 44};

    quickSort(arr, 0, 9);

    System.out.println(arr);


}

/**
 * 快速排序
 *
 * @param arr
 * @param L   指向数组第一个元素
 * @param R   指向数组最后一个元素
 */
public static void quickSort(int[] arr, int L, int R) {
    int i = L;
    int j = R;

    //支点
    int pivot = arr[(L + R) / 2];

    //左右两端进行扫描，只要两端还没有交替，就一直扫描
    while (i &lt;= j) {

        //寻找直到比支点大的数
        while (pivot &gt; arr[i])
            i++;

        //寻找直到比支点小的数
        while (pivot &lt; arr[j])
            j--;

        //此时已经分别找到了比支点小的数(右边)、比支点大的数(左边)，它们进行交换
        if (i &lt;= j) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            i++;
            j--;
        }
    }
    //上面一个while保证了第一趟排序支点的左边比支点小，支点的右边比支点大了。


    //“左边”再做排序，直到左边剩下一个数(递归出口)
    if (L &lt; j)
        quickSort(arr, L, j);

    //“右边”再做排序，直到右边剩下一个数(递归出口)
    if (i &lt; R)
        quickSort(arr, i, R);
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/04/快速排序/" data-id="cjkqla1ql00062kpxewv7z46j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-递归" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/03/递归/" class="article-date">
  <time datetime="2016-06-03T14:16:29.000Z" itemprop="datePublished">2016-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/03/递归/">递归</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="递归介绍"><a href="#递归介绍" class="headerlink" title="递归介绍"></a>递归介绍</h2><p>递归在程序语言中简单的理解是：方法自己调用自己。</p>
<p>递归其实和循环是非常像的，循环都可以改写成递归，递归未必能改写成循环，这是一个充分不必要的条件。</p>
<ul>
<li>那么，有了循环，为什么还要用递归呢？？在某些情况下(费波纳切数列，汉诺塔)，使用递归会比循环简单很多很多</li>
</ul>
<p>想要用递归必须知道两个条件：</p>
<ul>
<li>递归出口(终止递归的条件)</li>
<li>递归表达式(规律)</li>
</ul>
<p>技巧：在递归中常常是将问题切割成两个部分(1和整体的思想)，这能够让我们快速找到递归表达式(规律)</p>
<h2 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h2><p>如果我们使用for循环来进行求和1+2+3+4+….+100，那是很简单的：</p>
<pre><code>int sum = 0;
for (int i = 1; i &lt;= 100; i++) {

    sum = sum + i;

}
System.out.println(&quot;公众号：Java3y：&quot; + sum);
</code></pre><p>for循环都可以使用递归来进行改写，而使用递归必须要知道两个条件：</p>
<ul>
<li>递归出口</li>
<li>递归表达式(规律)</li>
</ul>
<p>我们来找出它的规律：1+2+3+…+n，这是一个求和的运算，那么我们可以假设X=1+2+3+…+n，可以将1+2+3+…+(n-1)看成是一个整体。而这个整体做的事又和我们的初始目的(求和)相同。以我们的高中数学知识我们又可以将上面的式子看成X=sum(n-1)+n</p>
<p>我们找到我们的递归表达式(规律)，它就是sum(n-1)+n,那递归出口呢，这个题目的递归出口就有很多了，我列举一下：</p>
<p>如果n=1时，那么就返回1<br>如果n=2时，那么就返回(1+2)=3<br>如果n=3时，那么就返回(1+2+3)=6</p>
<p>递归表达式和递归出口我们都找到了，下面就代码演示：</p>
<p>递归出口为1：</p>
<pre><code>public static void main(String[] args) {
    System.out.println(sum(100));
}

/**
 *
 * @param n 要加到的数字，比如题目的100
 * @return
 */
public static int sum(int n) {

    if (n == 1) {
        return 1;
    } else {
        return sum(n - 1) + n;
    }
}
</code></pre><h2 id="数组内部的最大值"><a href="#数组内部的最大值" class="headerlink" title="数组内部的最大值"></a>数组内部的最大值</h2><p>使用的是循环，那么我们通常这样实现：</p>
<pre><code>int[] arrays = {2, 3, 4, 5, 1, 5, 2, 9, 5, 6, 8, 3, 2};

//将数组的第一个假设是最大值
int max = arrays[0];

for (int i = 1; i &lt; arrays.length; i++) {

    if (arrays[i] &gt; max) {
        max = arrays[i];
    }
}

System.out.println(max);
</code></pre><p>如果我们用递归的话，那怎么用弄呢？首先还是先要找到递归表达式(规律)和递归出口</p>
<ul>
<li>我们又可以运用1和整体的思想来找到规律<ul>
<li>将数组第一个数-&gt;2与数组后面的数-&gt;{3, 4, 5, 1, 5, 2, 9, 5, 6, 8, 3, 2}进行切割，将数组后面的数看成是一个整体X={3, 4, 5, 1, 5, 2, 9, 5, 6, 8, 3, 2}，那么我们就可以看成是第一个数和一个整体进行比较if(2&gt;X) return 2  else(2&lt;X) return X</li>
<li>而我们要做的就是找出这个整体的最大值与2进行比较。找出整体的最大值又是和我们的初始目的(找出最大值)是一样的</li>
<li>也就可以写成if( 2&gt;findMax() )return 2 else return findMax()</li>
</ul>
</li>
<li>递归出口，如果数组只有1个元素时，那么这个数组最大值就是它了。</li>
</ul>
<p>使用到数组的时候，我们通常为数组设定左边界和右边界，这样比较好地进行切割。</p>
<ul>
<li>L表示左边界，往往表示的是数组第一个元素，也就会赋值为0(角标为0是数组的第一个元素)</li>
<li>R表示右边界，往往表示的是数组的长度，也就会赋值为arrays.length-1（长度-1在角标中才是代表最后一个元素)</li>
</ul>
<p>那么我们递归的写法就是：</p>
<pre><code>public static void main(String[] args) {

      int[] arrays = {2, 3, 4, 5, 1, 5, 2, 9, 5, 6, 8, 3, 1};

      System.out.println(findMax(arrays, 0, arrays.length - 1));

  }


  /**
   * 递归，找出数组最大的值
   * @param arrays 数组
   * @param L      左边界，第一个数
   * @param R      右边界，数组的长度
   * @return
   */

  public static int findMax(int[] arrays, int L, int R) {

      //如果该数组只有一个数，那么最大的就是该数组第一个值了
      if (L == R) {
          return arrays[L];
      } else {

          int a = arrays[L];
          int b = findMax(arrays, L + 1, R);//找出整体的最大值

          if (a &gt; b) {
              return a;
          } else {
              return b;
          }
      }

  }
</code></pre><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>菲波那切数列长这个样子：{1 1 2 3 5 8 13 21 34 55….. n }</p>
<p>数学好的同学可能很容易就找到规律了：前两项之和等于第三项</p>
<p>如果让我们求出第n项是多少，那么我们就可以很简单写出对应的递归表达式了：Z = (n-2) + (n-1)</p>
<p>递归出口在本题目是需要有两个的，因为它是前两项加起来才得出第三项的值</p>
<p>同样地，那么我们的递归出口可以写成这样：</p>
<pre><code>if(n==1) retrun 1;
if(n==2) return 2;
</code></pre><p>看一下完整的代码:</p>
<pre><code>public static void main(String[] args) {

    int[] arrays = {1, 1, 2, 3, 5, 8, 13, 21};
    //bubbleSort(arrays, 0, arrays.length - 1);

    int fibonacci = fibonacci(10);
    System.out.println(fibonacci);

}

public static int fibonacci(int n) {
    if (n == 1) {
        return 1;
    } else if (n == 2) {
        return 1;
    } else {
        return (fibonacci(n - 1) + fibonacci(n - 2));
    }

}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>要使用递归首先要知道两件事：</p>
<ul>
<li>递归出口(终止递归的条件)</li>
<li>递归表达式(规律)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/03/递归/" data-id="cjkqla1qn00072kpxih05ocyk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-冒泡排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/03/冒泡排序/" class="article-date">
  <time datetime="2016-06-03T14:16:29.000Z" itemprop="datePublished">2016-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/03/冒泡排序/">冒泡排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="冒泡排序就这么简单"><a href="#冒泡排序就这么简单" class="headerlink" title="冒泡排序就这么简单"></a>冒泡排序就这么简单</h2><p>排序对我们来说是一点也不陌生了，当你打Dota的时候也有天梯分，从高往下数，这个排名是有规律的，就是一种排序。</p>
<h2 id="冒泡排序的实现"><a href="#冒泡排序的实现" class="headerlink" title="冒泡排序的实现"></a>冒泡排序的实现</h2><blockquote>
<p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名冒泡排序。</p>
</blockquote>
<p>算法描述：</p>
<ul>
<li>i从0开始，i与i+1比较，如果i&gt;i+1，那么就互换</li>
<li>i不断增加，直到i&lt;n-1（n是数组元素的个数，n-1是数组已经最后一个元素） ，一趟下来，可以让数组元素中最大值排在数组的最后面</li>
</ul>
<p>从最简单开始，首先我们创建一个数组，该数组有6位数字：</p>
<pre><code>int[] arrays = {8, 3, 2, 6, 7, 9};
</code></pre><p>6位数的数组需要5躺排序的，每躺排序之后次数减1(因为前一趟已经把前一趟数的最大值确定下来了)！</p>
<p>于是我们可以根据for循环和变量将上面的代码进行排序：</p>
<pre><code>int temp;

//外层循环是排序的趟数
for (int i = 0; i &lt; arrays.length - 1 ; i++) {

    //内层循环是当前趟数需要比较的次数
    for (int j = 0; j &lt; arrays.length - i - 1; j++) {

        //前一位与后一位与前一位比较，如果前一位比后一位要大，那么交换
        if (arrays[j] &gt; arrays[j + 1]) {
            temp = arrays[j];
            arrays[j] = arrays[j + 1];
            arrays[j + 1] = temp;
        }
    }
}
</code></pre><h2 id="冒泡排序优化"><a href="#冒泡排序优化" class="headerlink" title="冒泡排序优化"></a>冒泡排序优化</h2><p>从上面的例子我们可以看出来，如果数据足够乱的情况下是需要经过5躺比较才能将数组完整排好序。但是我们在第二躺比较后就已经得到排好序的数组了。</p>
<p>但是，我们的程序在第二趟排序后仍会执行第三趟、第四趟排序。这是没有必要的，因此我们可以对其进行优化一下：</p>
<ul>
<li>如果在某躺排序中没有发生交换位置，那么我们可以认为该数组已经排好序了<ul>
<li>因为我们每趟排序的目的就是将当前趟最大的数置换到对应的位置上，没有发生置换说明就已经排好序了</li>
</ul>
</li>
</ul>
<p>代码如下：</p>
<pre><code>//装载临时变量
int temp;

//记录是否发生了置换， 0 表示没有发生置换、 1 表示发生了置换
int isChange;

//外层循环是排序的趟数
for (int i = 0; i &lt; arrays.length - 1; i++) {

    //每比较一趟就重新初始化为0
    isChange = 0;

    //内层循环是当前趟数需要比较的次数
    for (int j = 0; j &lt; arrays.length - i - 1; j++) {

        //前一位与后一位与前一位比较，如果前一位比后一位要大，那么交换
        if (arrays[j] &gt; arrays[j + 1]) {
            temp = arrays[j];
            arrays[j] = arrays[j + 1];
            arrays[j + 1] = temp;

            //如果进到这里面了，说明发生置换了
            isChange = 1;

        }
    }
    //如果比较完一趟没有发生置换，那么说明已经排好序了，不需要再执行下去了
    if (isChange == 0) {
        break;
    }
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/06/03/冒泡排序/" data-id="cjkqla1r7000d2kpxf6q7a3vx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Jinxing Chen<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>



<script src="/js/script.js"></script>

  </div>
</body>
</html>